<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neon CS Multiplayer Shooter v2</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Firebase SDKs -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        // FIX: Added 'query' import below
        import { getFirestore, doc, setDoc, onSnapshot, collection, serverTimestamp, updateDoc, deleteDoc, getDoc, runTransaction, query } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        import { setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Global Firebase instances (accessible globally in this script)
        window.initializeApp = initializeApp;
        window.getAuth = getAuth;
        window.signInAnonymously = signInAnonymously;
        window.signInWithCustomToken = signInWithCustomToken;
        window.onAuthStateChanged = onAuthStateChanged;
        window.getFirestore = getFirestore;
        window.doc = doc;
        window.setDoc = setDoc;
        window.onSnapshot = onSnapshot;
        window.collection = collection;
        window.query = query; // FIX: Added query to global exports
        window.serverTimestamp = serverTimestamp;
        window.updateDoc = updateDoc;
        window.deleteDoc = deleteDoc;
        window.getDoc = getDoc;
        window.runTransaction = runTransaction;
        window.setLogLevel = setLogLevel;
    </script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Major+Mono+Display&display=swap');
        
        /* Neon Colors */
        :root {
            --neon-green: #00FF00; /* CT Team Color */
            --neon-cyan: #00FFFF;
            --neon-red: #FF0055; /* T Team Color */
            --neon-yellow: #FFD700;
            --dark-bg: #030303;
        }

        body {
            font-family: 'Major Mono Display', monospace;
            background-color: var(--dark-bg);
            color: var(--neon-cyan);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            overflow: auto; /* Allow scrolling for large map */
            flex-direction: column;
        }

        canvas {
            border: 4px solid var(--neon-cyan);
            box-shadow: 0 0 25px var(--neon-cyan);
            background-color: #000000;
            display: block;
            touch-action: none;
            cursor: crosshair;
        }

        .game-info {
            background-color: #111;
            border: 2px solid var(--neon-red);
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            box-shadow: 0 0 10px var(--neon-red);
        }

        .neon-button {
            transition: all 0.1s ease-in-out;
            border: 2px solid var(--neon-green);
            background-color: #000;
            color: var(--neon-green);
            padding: 0.5rem 1.5rem;
            border-radius: 0.5rem;
            box-shadow: 0 0 10px var(--neon-green);
            cursor: pointer;
        }

        .neon-button:hover {
            background-color: var(--neon-green);
            color: #000;
            box-shadow: 0 0 20px var(--neon-green), 0 0 5px var(--neon-green) inset;
        }
        
        .neon-input {
            background-color: #111;
            border: 2px solid var(--neon-cyan);
            color: var(--neon-yellow);
            padding: 0.5rem;
            border-radius: 0.5rem;
            box-shadow: 0 0 5px var(--neon-cyan);
            outline: none;
        }

        .menu-container {
            width: 90%;
            max-width: 400px;
            padding: 2rem;
            background: #111;
            border: 4px solid var(--neon-red);
            box-shadow: 0 0 30px var(--neon-red);
            border-radius: 1rem;
        }

        .lobby-container {
            width: 90%;
            max-width: 600px;
            padding: 2rem;
            background: #111;
            border: 4px solid var(--neon-cyan);
            box-shadow: 0 0 30px var(--neon-cyan);
            border-radius: 1rem;
        }
    </style>
</head>
<body>
    <h1 class="text-4xl mb-4" style="color:var(--neon-yellow); text-shadow: 0 0 10px var(--neon-yellow);">NEON BOT & MULTIPLAYER SHOOTER</h1>
    
    <!-- Game UI (Hidden initially) -->
    <div id="gameUI" class="hidden flex flex-col items-center">
        <div class="mb-4 flex gap-4 w-full justify-around text-lg">
            <div id="scoreDisplay" class="game-info text-center text-white" style="border-color: var(--neon-yellow); box-shadow: 0 0 15px var(--neon-yellow);">Kills: 0 | Deaths: 0</div>
            <div id="healthDisplay" class="game-info text-center text-white" style="border-color: var(--neon-green); box-shadow: 0 0 15px var(--neon-green);">Health: 100</div>
            <div id="ammoDisplay" class="game-info text-center text-white" style="border-color: var(--neon-cyan); box-shadow: 0 0 15px var(--neon-cyan);">AK-47 | 30/90</div>
        </div>

        <canvas id="gameCanvas" width="1200" height="900"></canvas>

        <div class="mt-4 text-center text-white text-sm">
            Controls: **WASD** / **Arrows** to move. **Mouse** to aim. **Click** to shoot. **R** to reload. **1/2/3** for weapons.
        </div>
        <div id="userIdDisplay" class="mt-2 text-xs text-gray-500">Your ID: Loading...</div>
    </div>

    <!-- Main Menu (Visible initially) -->
    <div id="mainMenu" class="menu-container text-center">
        <h2 class="text-2xl mb-6" style="color: var(--neon-cyan);">Main Menu</h2>
        <input type="text" id="playerNameInput" placeholder="Enter Player Name (e.g., Spectre)" class="neon-input w-full mb-4 text-center">
        
        <button id="botsButton" class="neon-button w-full mb-4" style="--neon-green: var(--neon-cyan);">Play with Bots (Local)</button>

        <p class="mb-2">--- MULTIPLAYER (Firebase) ---</p>

        <button id="hostButton" class="neon-button w-full mb-4" style="--neon-green: var(--neon-yellow);">Host Game</button>
        <input type="text" id="roomIdInput" placeholder="Enter Room ID to Join" class="neon-input w-full mb-4 text-center">
        <button id="joinButton" class="neon-button w-full" style="--neon-green: var(--neon-green);">Join Game</button>
        
        <p id="menuStatus" class="mt-4 text-sm text-red-500"></p>
    </div>

    <!-- Lobby/Message Box Screen -->
    <div id="messageBox" class="fixed top-0 left-0 w-full h-full bg-black bg-opacity-75 hidden z-10 justify-center items-center">
        <div id="lobbyContainer" class="lobby-container text-center">
            <h2 id="finalScore" class="text-4xl mb-4" style="color:var(--neon-yellow);">Lobby</h2>
            <p id="highScoreText" class="text-xl mb-6">Room ID: <span id="lobbyRoomId" class="font-bold text-lg" style="color: var(--neon-green);"></span></p>
            <div id="playerList" class="mb-6 text-left p-4 rounded" style="background: #080808; border: 1px solid #333;">
                <!-- Player list goes here -->
            </div>
            <button id="startGameButton" class="neon-button hidden">Start Game</button>
            <button id="leaveButton" class="neon-button" style="--neon-green: var(--neon-red);">Leave Room</button>
        </div>
    </div>

    <script>
        // --- Firebase Globals (Provided by Canvas Environment) ---
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {};
        const authToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;
        
        // --- Game/UI Globals ---
        let db, auth, userId, roomRef, roomSnapshotUnsubscribe;
        let playerName = `Player${Math.floor(Math.random() * 1000)}`;
        let roomData = null;
        let gameMode = 'MENU'; // 'MENU', 'BOTS', 'MULTIPLAYER'
        let bots = []; // Bot entities for local game mode
        
        let localPlayerState = {};

        // --- Game State ---
        let canvas, ctx;
        let entities = []; // All players/bots from the roomData
        let bullets = [];
        let keys = {};
        let lastShotTime = 0;
        let gameLoopId;
        let isRunning = false;
        let mousePos = { x: 0, y: 0 };
        
        // --- Configuration ---
        const NEON_GREEN = '#00FF00'; // CT Team Color
        const NEON_RED = '#FF0055';   // T Team Color
        const NEON_CYAN = '#00FFFF';
        const NEON_YELLOW = '#FFD700';
        const MAP_COLOR = '#111111';
        const WALL_COLOR = '#777777';
        const CANVAS_WIDTH = 1200; // Increased size
        const CANVAS_HEIGHT = 900; // Increased size
        const MAP_SCALE = 0.15;
        const PLAYER_SPEED = 3;
        const PLAYER_RADIUS = 10;
        const SYNC_RATE = 100; // milliseconds for state sync (10 FPS)
        const RELOAD_TIME_MS = 2000;
        let lastSyncTime = 0;

        // --- Weapon Definitions ---
        const WEAPONS = {
            'KNIFE': { id: 3, name: 'Knife', damage: 50, fireRate: 500, range: 25, bulletSpeed: 0, clip: 1, maxAmmo: 999, color: NEON_YELLOW, bulletRadius: 0, isMelee: true },
            'DEAGLE': { id: 2, name: 'Deagle', damage: 50, fireRate: 500, range: 600, bulletSpeed: 10, clip: 7, maxAmmo: 35, color: NEON_YELLOW, bulletRadius: 3, isMelee: false },
            'AK47': { id: 1, name: 'AK-47', damage: 25, fireRate: 120, range: 800, bulletSpeed: 12, clip: 30, maxAmmo: 90, color: NEON_CYAN, bulletRadius: 2, isMelee: false }
        };

        // Initialize ammo state globally (local to client)
        let ammo = {};

        function resetAmmo() {
            ammo = {
                '1': { currentClip: WEAPONS.AK47.clip, reserve: WEAPONS.AK47.maxAmmo },
                '2': { currentClip: WEAPONS.DEAGLE.clip, reserve: WEAPONS.DEAGLE.maxAmmo },
                '3': { currentClip: WEAPONS.KNIFE.clip, reserve: WEAPONS.KNIFE.maxAmmo }
            };
        }
        
        // --- Map Data (Larger and more complex) ---
        const DUST2_WALLS = [
            // Outer boundaries
            { x: 0, y: 0, w: CANVAS_WIDTH, h: 5, type: 'wall' }, { x: 0, y: CANVAS_HEIGHT - 5, w: CANVAS_WIDTH, h: 5, type: 'wall' }, 
            { x: 0, y: 5, w: 5, h: CANVAS_HEIGHT - 10, type: 'wall' }, { x: CANVAS_WIDTH - 5, y: 5, w: 5, h: CANVAS_HEIGHT - 10, type: 'wall' }, 
            
            // Central structure (mid)
            { x: 500, y: 0, w: 20, h: 250, type: 'wall' }, 
            { x: 500, y: 650, w: 20, h: 250, type: 'wall' },
            { x: 500, y: 230, w: 200, h: 20, type: 'wall' }, // Cross mid
            { x: 500, y: 650, w: 200, h: 20, type: 'wall' }, // Cross mid bottom
            
            // Site A area (Top Right)
            { x: 800, y: 50, w: 20, h: 300, type: 'wall' },
            { x: 800, y: 350, w: 350, h: 20, type: 'wall' },
            { x: 1100, y: 50, w: 50, h: 20, type: 'wall' },
            
            // Site B area (Bottom Left)
            { x: 50, y: 800, w: 400, h: 20, type: 'wall' },
            { x: 450, y: 550, w: 20, h: 270, type: 'wall' },
            { x: 50, y: 550, w: 20, h: 200, type: 'wall' },
            
            // Long Hallway (Left Side)
            { x: 100, y: 150, w: 20, h: 500, type: 'wall' },
            { x: 120, y: 630, w: 200, h: 20, type: 'wall' },
            { x: 300, y: 150, w: 20, h: 480, type: 'wall' },
        ];

        const CT_SPAWN = { x: 50, y: 50 };
        const T_SPAWN = { x: CANVAS_WIDTH - 50, y: CANVAS_HEIGHT - 50 };

        // --- UI Element References ---
        const gameUI = document.getElementById('gameUI');
        const mainMenu = document.getElementById('mainMenu');
        const messageBox = document.getElementById('messageBox');
        const lobbyContainer = document.getElementById('lobbyContainer');
        const lobbyRoomId = document.getElementById('lobbyRoomId');
        const playerListDiv = document.getElementById('playerList');
        const startGameButton = document.getElementById('startGameButton');
        const menuStatus = document.getElementById('menuStatus');
        const playerNameInput = document.getElementById('playerNameInput');
        const userIdDisplay = document.getElementById('userIdDisplay');
        const botsButton = document.getElementById('botsButton');
        const roomIdInput = document.getElementById('roomIdInput');
        const hostButton = document.getElementById('hostButton');
        const joinButton = document.getElementById('joinButton');

        // --- Utility Functions ---

        /** Calculates the distance between two points. */
        function distance(x1, y1, x2, y2) {
            return Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
        }

        /** Checks circular entity collision with rectangular walls (AABB collision). */
        function checkWallCollision(entity, walls) {
            let collided = false;
            for (const wall of walls) {
                const closestX = Math.max(wall.x, Math.min(entity.x, wall.x + wall.w));
                const closestY = Math.max(wall.y, Math.min(entity.y, wall.y + wall.h));
                const dx = entity.x - closestX;
                const dy = entity.y - closestY;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist < entity.radius) {
                    const overlap = entity.radius - dist;
                    if (dist === 0) continue; 
                    const nx = dx / dist;
                    const ny = dy / dist;
                    entity.x += nx * overlap;
                    entity.y += ny * overlap;
                    collided = true;
                }
            }
            return collided;
        }

        // --- Core Firebase Functions ---

        async function firebaseInit() {
            try {
                // setLogLevel('debug'); // Enable for debugging Firestore
                const app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);
                
                await new Promise(resolve => {
                    const unsubscribe = onAuthStateChanged(auth, async (user) => {
                        if (user) {
                            userId = user.uid;
                            resolve();
                            unsubscribe();
                        } else if (authToken) {
                            await signInWithCustomToken(auth, authToken);
                        } else {
                            await signInAnonymously(auth);
                        }
                    });
                });
                
                userIdDisplay.textContent = `Your ID: ${userId}`;
                playerNameInput.value = playerName;

            } catch (error) {
                console.error("Firebase initialization failed:", error);
                menuStatus.textContent = "Error: Failed to connect to game services.";
            }
        }
        
        function getRoomPath(roomId) {
            return doc(db, 'artifacts', appId, 'public', 'data', 'neon_cs_rooms', roomId);
        }

        function generateRoomId() {
            return Math.floor(1000 + Math.random() * 9000).toString();
        }

        async function hostGame() {
            if (!userId) return;
            playerName = playerNameInput.value || playerName;
            gameMode = 'MULTIPLAYER';

            const newRoomId = generateRoomId();
            roomRef = getRoomPath(newRoomId);

            const initialData = {
                status: 'LOBBY',
                hostId: userId,
                map: 'dust2_v2',
                timestamp: serverTimestamp(),
                players: {
                    [userId]: createNewPlayerState(userId, playerName, 'CT', CT_SPAWN)
                }
            };

            try {
                await setDoc(roomRef, initialData);
                enterLobby(newRoomId, initialData);
            } catch (error) {
                console.error("Error hosting game:", error);
                menuStatus.textContent = "Error: Failed to create room.";
            }
        }

        async function joinGame() {
            if (!userId) return;
            playerName = playerNameInput.value || playerName;
            const joinRoomId = roomIdInput.value.trim();
            if (!joinRoomId) {
                menuStatus.textContent = "Please enter a Room ID.";
                return;
            }
            gameMode = 'MULTIPLAYER';

            roomRef = getRoomPath(joinRoomId);

            try {
                await runTransaction(db, async (transaction) => {
                    const roomDoc = await transaction.get(roomRef);
                    if (!roomDoc.exists()) {
                        throw new Error("Room not found.");
                    }
                    
                    const data = roomDoc.data();
                    if (data.status !== 'LOBBY') {
                         throw new Error("Game already in progress.");
                    }

                    const existingPlayers = Object.keys(data.players || {});
                    
                    // Simple team assignment: Alternate CT/T
                    const team = existingPlayers.length % 2 === 0 ? 'CT' : 'T'; 
                    const spawn = team === 'CT' ? CT_SPAWN : T_SPAWN;

                    const newPlayer = createNewPlayerState(userId, playerName, team, spawn);
                    
                    data.players[userId] = newPlayer;
                    transaction.update(roomRef, { players: data.players });
                    return data;

                }).then(data => {
                    enterLobby(joinRoomId, data);
                });

            } catch (error) {
                console.error("Error joining game:", error);
                menuStatus.textContent = `Error: ${error.message || "Failed to join room."}`;
            }
        }

        function createNewPlayerState(id, name, team, spawn) {
             return {
                id: id,
                name: name,
                team: team,
                x: spawn.x,
                y: spawn.y,
                angle: 0,
                health: 100,
                kills: 0,
                deaths: 0,
                radius: PLAYER_RADIUS,
                currentWeaponId: WEAPONS.AK47.id,
                isReloading: false
            };
        }

        function leaveRoom() {
            if (roomSnapshotUnsubscribe) {
                roomSnapshotUnsubscribe();
            }
            if (roomRef && userId && gameMode === 'MULTIPLAYER') {
                const updatePayload = {};
                updatePayload[`players.${userId}`] = deleteDoc;
                updateDoc(roomRef, updatePayload).catch(e => console.error("Failed to clean up player data:", e));

                if (roomData && roomData.hostId === userId) {
                    updateDoc(roomRef, { status: 'FINISHED' }).catch(e => console.error("Failed to mark room finished:", e));
                }
            }
            
            // Cleanup UI and state
            roomData = null;
            isRunning = false;
            gameMode = 'MENU';
            bots = [];
            if (gameLoopId) cancelAnimationFrame(gameLoopId);
            
            gameUI.classList.add('hidden');
            messageBox.classList.add('hidden');
            mainMenu.classList.remove('hidden');
            menuStatus.textContent = "";
            playerListDiv.innerHTML = "";
            
            // Reset player state to default
            resetLocalPlayerState();
            removeGameListeners();
        }

        async function syncLocalPlayerState() {
            if (!isRunning || !roomRef || !localPlayerState.health || gameMode !== 'MULTIPLAYER') return;

            const now = Date.now();
            if (now - lastSyncTime < SYNC_RATE) return;
            lastSyncTime = now;
            
            const updatePayload = {};
            updatePayload[`players.${userId}.x`] = localPlayerState.x;
            updatePayload[`players.${userId}.y`] = localPlayerState.y;
            updatePayload[`players.${userId}.angle`] = localPlayerState.angle;
            updatePayload[`players.${userId}.health`] = localPlayerState.health;
            updatePayload[`players.${userId}.kills`] = localPlayerState.kills;
            updatePayload[`players.${userId}.deaths`] = localPlayerState.deaths;
            updatePayload[`players.${userId}.currentWeaponId`] = localPlayerState.currentWeaponId;
            updatePayload[`players.${userId}.isReloading`] = localPlayerState.isReloading;


            try {
                await updateDoc(roomRef, updatePayload);
            } catch (error) {
                console.error("Failed to sync player state:", error);
            }
        }
        
        // --- UI/Lobby Functions ---

        function enterLobby(roomId, data) {
            roomData = data;
            mainMenu.classList.add('hidden');
            gameUI.classList.add('hidden');
            messageBox.classList.remove('hidden');
            lobbyContainer.style.borderColor = data.hostId === userId ? NEON_YELLOW : NEON_CYAN;
            lobbyContainer.style.boxShadow = data.hostId === userId ? `0 0 30px ${NEON_YELLOW}` : `0 0 30px ${NEON_CYAN}`;

            lobbyRoomId.textContent = roomId;
            
            startGameButton.classList.toggle('hidden', data.hostId !== userId);
            
            listenToRoom(roomId);
        }

        function updateLobbyUI(data) {
            roomData = data;
            playerListDiv.innerHTML = '';

            if (data.status === 'INGAME') {
                if (!isRunning) initializeGame(data);
                return;
            } else if (data.status === 'FINISHED') {
                gameOver("The host left the game.", false);
                return;
            }

            // Update Player List
            const players = Object.values(data.players || {});
            players.forEach(p => {
                const teamColor = p.team === 'CT' ? NEON_GREEN : NEON_RED;
                const element = document.createElement('p');
                element.className = 'text-sm mb-1';
                element.innerHTML = `<span style="color: ${teamColor};">${p.team}</span> | ${p.name} ${p.id === data.hostId ? '(HOST)' : ''} ${p.id === userId ? '(YOU)' : ''}`;
                playerListDiv.appendChild(element);
            });
        }
        
        function listenToRoom(roomId) {
            if (roomSnapshotUnsubscribe) roomSnapshotUnsubscribe();

            roomRef = getRoomPath(roomId);
            // Note: The 'query' function is actually not being used here, 
            // but the variable was missing from the import list, causing the error.
            roomSnapshotUnsubscribe = onSnapshot(roomRef, (doc) => {
                if (doc.exists()) {
                    updateLobbyUI(doc.data());
                } else {
                    if (isRunning) gameOver("Room disbanded.", false);
                    leaveRoom();
                }
            }, (error) => {
                console.error("Firestore Listener Error:", error);
                if (isRunning) gameOver("Connection lost.", false);
                leaveRoom();
            });
        }

        // --- Bot Functions ---

        function startBotsGame() {
            gameMode = 'BOTS';
            playerName = playerNameInput.value || playerName;
            
            localPlayerState = createNewPlayerState(userId, playerName, 'CT', CT_SPAWN);
            resetAmmo();

            // Create 4 bots
            bots = [];
            for (let i = 0; i < 4; i++) {
                const botId = `bot_${i}`;
                const botName = `Bot ${i+1}`;
                const spawn = T_SPAWN; // Bots are always on T team
                bots.push({
                    ...createNewPlayerState(botId, botName, 'T', spawn),
                    moveAngle: Math.random() * Math.PI * 2,
                    lastShot: Date.now(),
                    targetId: userId // Always target the player
                });
            }

            initializeGame(null); // Null data since it's local
        }

        function updateBots() {
            if (gameMode !== 'BOTS' || localPlayerState.health <= 0) return;
            
            bots.forEach(bot => {
                if (bot.health <= 0) return;

                const target = localPlayerState;
                const distToTarget = distance(bot.x, bot.y, target.x, target.y);

                // 1. Aim
                bot.angle = Math.atan2(target.y - bot.y, target.x - bot.x);

                // 2. Movement (Move towards the player if far, wander if close)
                if (distToTarget > 200) {
                    bot.x += Math.cos(bot.angle) * (PLAYER_SPEED * 0.7);
                    bot.y += Math.sin(bot.angle) * (PLAYER_SPEED * 0.7);
                } else if (Math.random() < 0.005) { // 0.5% chance to wander
                    bot.moveAngle = Math.random() * Math.PI * 2;
                    bot.x += Math.cos(bot.moveAngle) * (PLAYER_SPEED * 0.5);
                    bot.y += Math.sin(bot.moveAngle) * (PLAYER_SPEED * 0.5);
                }

                // Check and resolve wall collisions (updates bot position in place)
                checkWallCollision(bot, DUST2_WALLS);

                // 3. Shooting
                if (Date.now() - bot.lastShot > 500 && distToTarget < 600) {
                    shootBot(bot);
                    bot.lastShot = Date.now();
                }
            });
        }

        function shootBot(bot) {
             const currentWeapon = WEAPONS.AK47;
             const bulletSpeed = currentWeapon.bulletSpeed;
             
             // Add some inaccuracy
             const inaccuracy = (Math.random() - 0.5) * 0.2; // +/- 0.2 radians
             const angle = bot.angle + inaccuracy;

             const velocityX = Math.cos(angle) * bulletSpeed;
             const velocityY = Math.sin(angle) * bulletSpeed;

             const muzzleX = bot.x + Math.cos(bot.angle) * (PLAYER_RADIUS + 10);
             const muzzleY = bot.y + Math.sin(bot.angle) * (PLAYER_RADIUS + 10);

             bullets.push({
                 x: muzzleX, y: muzzleY, radius: currentWeapon.bulletRadius,
                 velocityX: velocityX, velocityY: velocityY, damage: currentWeapon.damage,
                 shooterId: bot.id, color: NEON_RED,
                 targetType: 'PLAYER' // Bot bullets target the player
             });
        }

        // --- Drawing Functions (No change, as they rely on entities array) ---

        function drawMap() {
            ctx.fillStyle = MAP_COLOR;
            ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

            // Draw Walls
            ctx.fillStyle = WALL_COLOR;
            DUST2_WALLS.forEach(wall => {
                ctx.fillRect(wall.x, wall.y, wall.w, wall.h);
            });
        }

        function drawEntities() {
            entities.forEach(e => {
                if (e.health <= 0) return;

                ctx.save();
                ctx.translate(e.x, e.y);
                ctx.rotate(e.angle);
                
                const teamColor = e.team === 'CT' ? NEON_GREEN : NEON_RED;
                ctx.fillStyle = teamColor;
                ctx.shadowColor = ctx.fillStyle;
                ctx.shadowBlur = 10;
                ctx.beginPath();
                ctx.arc(0, 0, PLAYER_RADIUS, 0, Math.PI * 2);
                ctx.fill();

                ctx.shadowBlur = 0;
                ctx.fillStyle = NEON_CYAN;
                ctx.font = '10px Major Mono Display';
                ctx.textAlign = 'center';
                ctx.fillText(e.name, 0, -15);
                
                // Draw directional pointer/Muzzle
                ctx.strokeStyle = NEON_CYAN;
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(PLAYER_RADIUS, 0);
                ctx.lineTo(PLAYER_RADIUS + 10, 0);
                ctx.stroke();

                // Draw health bar
                const healthBarWidth = 20;
                const healthBarHeight = 3;
                const healthRatio = e.health / 100;
                ctx.fillStyle = healthRatio > 0.5 ? NEON_GREEN : (healthRatio > 0.2 ? NEON_YELLOW : NEON_RED);
                ctx.fillRect(-healthBarWidth / 2, PLAYER_RADIUS + 5, healthBarWidth * healthRatio, healthBarHeight);
                ctx.strokeStyle = WALL_COLOR;
                ctx.strokeRect(-healthBarWidth / 2, PLAYER_RADIUS + 5, healthBarWidth, healthBarHeight);

                ctx.restore();
                ctx.shadowBlur = 0;
            });
        }

        function drawBullets() {
            bullets.forEach(b => {
                ctx.fillStyle = b.color;
                ctx.shadowColor = b.color;
                ctx.shadowBlur = 5;
                ctx.beginPath();
                ctx.arc(b.x, b.y, b.radius, 0, Math.PI * 2);
                ctx.fill();
            });
            ctx.shadowBlur = 0;
        }

        function drawMinimap() {
            // Note: The map scale needs to be adjusted for the larger map size for a better view
            const scale = 0.1; 
            const mapW = CANVAS_WIDTH * scale;
            const mapH = CANVAS_HEIGHT * scale;
            const mapX = 10;
            const mapY = 10;
            const markerRadius = 2;

            // Background Frame
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(mapX - 5, mapY - 5, mapW + 10, mapH + 10);
            ctx.strokeStyle = NEON_CYAN;
            ctx.strokeRect(mapX - 5, mapY - 5, mapW + 10, mapH + 10);
            
            ctx.save();
            ctx.translate(mapX, mapY);

            // Draw Walls
            ctx.fillStyle = WALL_COLOR;
            DUST2_WALLS.forEach(wall => {
                ctx.fillRect(wall.x * scale, wall.y * scale, wall.w * scale, wall.h * scale);
            });

            // Draw Entities
            entities.forEach(e => {
                if (e.health <= 0) return;
                ctx.fillStyle = e.team === 'CT' ? NEON_GREEN : NEON_RED;
                if (e.id === userId) ctx.fillStyle = NEON_YELLOW;
                ctx.beginPath();
                ctx.arc(e.x * scale, e.y * scale, markerRadius, 0, Math.PI * 2);
                ctx.fill();
            });

            ctx.restore();
        }

        // --- Game Logic Updates ---

        function updatePlayerMovement() {
            if (localPlayerState.health <= 0 || localPlayerState.isReloading) return;

            let dx = 0, dy = 0;
            
            if (keys['w'] || keys['W'] || keys['ArrowUp']) dy -= PLAYER_SPEED;
            if (keys['s'] || keys['S'] || keys['ArrowDown']) dy += PLAYER_SPEED;
            if (keys['a'] || keys['A'] || keys['ArrowLeft']) dx -= PLAYER_SPEED;
            if (keys['d'] || keys['D'] || keys['ArrowRight']) dx += PLAYER_SPEED;
            
            if (dx !== 0 || dy !== 0) {
                localPlayerState.x += dx;
                localPlayerState.y += dy;
                
                // FIX: Add canvas boundary clamping here
                // Ensure player stays within the bounds of the canvas, accounting for player radius
                localPlayerState.x = Math.max(PLAYER_RADIUS, Math.min(CANVAS_WIDTH - PLAYER_RADIUS, localPlayerState.x));
                localPlayerState.y = Math.max(PLAYER_RADIUS, Math.min(CANVAS_HEIGHT - PLAYER_RADIUS, localPlayerState.y));

                checkWallCollision(localPlayerState, DUST2_WALLS);
            }
        }
        
        function updateAim(event) {
            if (!isRunning) return;
            const rect = canvas.getBoundingClientRect();
            mousePos.x = event.clientX - rect.left;
            mousePos.y = event.clientY - rect.top;

            localPlayerState.angle = Math.atan2(mousePos.y - localPlayerState.y, mousePos.x - localPlayerState.x);
        }

        function updateBullets() {
            for (let i = bullets.length - 1; i >= 0; i--) {
                const b = bullets[i];
                b.x += b.velocityX;
                b.y += b.velocityY;
                
                // Bullet collision with Walls
                for (const wall of DUST2_WALLS) {
                    if (b.x > wall.x && b.x < wall.x + wall.w && b.y > wall.y && b.y < wall.y + wall.h) {
                        bullets.splice(i, 1);
                        i--;
                        continue;
                    }
                }
            }

            // Remove off-screen bullets
            bullets = bullets.filter(b => 
                b.x > 0 && b.x < CANVAS_WIDTH && b.y > 0 && b.y < CANVAS_HEIGHT
            );
        }

        function checkDamageCollisions() {
            // Check local bullets against targets
            for (let i = bullets.length - 1; i >= 0; i--) {
                const b = bullets[i];
                let bulletHit = false;
                let targetId = null;
                let isBotHit = false;
                
                // Determine target list: bots or remote players
                const targets = gameMode === 'BOTS' ? bots : entities.filter(e => e.id !== userId);
                
                if (gameMode === 'BOTS' && b.targetType === 'PLAYER') {
                    // Bot bullet hit check against local player
                    if (distance(b.x, b.y, localPlayerState.x, localPlayerState.y) < b.radius + PLAYER_RADIUS) {
                        localPlayerState.health -= b.damage;
                        bulletHit = true;
                        
                        if (localPlayerState.health <= 0) {
                            localPlayerState.deaths++;
                            // Simple bot respawn logic
                            localPlayerState.x = CT_SPAWN.x;
                            localPlayerState.y = CT_SPAWN.y;
                            localPlayerState.health = 100;
                        }
                    }
                } else {
                    // Player bullet hit check against bots or remote players
                    for (let j = 0; j < targets.length; j++) {
                        const t = targets[j];
                        if (t.health <= 0) continue; 
                        
                        if (distance(b.x, b.y, t.x, t.y) < b.radius + PLAYER_RADIUS) {
                            targetId = t.id;
                            isBotHit = gameMode === 'BOTS';
                            bulletHit = true;
                            break;
                        }
                    }
                }

                if (bulletHit && targetId) {
                    if (isBotHit) {
                        // Local update for bot hit
                        const botIndex = bots.findIndex(bot => bot.id === targetId);
                        if (botIndex !== -1) {
                            const bot = bots[botIndex];
                            bot.health -= b.damage;
                            if (bot.health <= 0) {
                                localPlayerState.kills++;
                                // Simple bot respawn
                                bot.x = T_SPAWN.x + Math.random() * 100 - 50;
                                bot.y = T_SPAWN.y + Math.random() * 100 - 50;
                                bot.health = 100;
                            }
                        }
                    } else if (gameMode === 'MULTIPLAYER') {
                        // Multiplayer update via transaction
                        processHit(targetId, b.shooterId, b.damage);
                    }
                    bullets.splice(i, 1);
                    i--;
                } else if (bulletHit) {
                    // Bullet hit local player (handled above) or hit a target but no ID (e.g., self-hit prevention)
                    bullets.splice(i, 1);
                    i--;
                }
            }
        }
        
        async function processHit(targetId, shooterId, damage) {
            if (targetId === shooterId) return; 
            
            try {
                await runTransaction(db, async (transaction) => {
                    const roomDoc = await transaction.get(roomRef);
                    if (!roomDoc.exists()) throw "Room does not exist!";
                    
                    const data = roomDoc.data();
                    const target = data.players[targetId];
                    const shooter = data.players[shooterId];

                    if (target && target.health > 0) {
                        target.health -= damage;
                        
                        if (target.health <= 0) {
                            target.deaths = (target.deaths || 0) + 1;
                            shooter.kills = (shooter.kills || 0) + 1;
                            
                            // Respawn
                            const spawn = target.team === 'CT' ? CT_SPAWN : T_SPAWN;
                            target.x = spawn.x;
                            target.y = spawn.y;
                            target.health = 100;
                        }
                        
                        const updates = {};
                        updates[`players.${targetId}`] = target;
                        updates[`players.${shooterId}`] = shooter;
                        transaction.update(roomRef, updates);
                    }
                });
            } catch (error) {
                console.error("Transaction failed:", error);
            }
        }
        
        // --- Weapon & Ammo Functions ---
        
        function reloadGun() {
            if (localPlayerState.health <= 0 || localPlayerState.isReloading) return;

            const currentWeapon = WEAPONS[Object.keys(WEAPONS).find(key => WEAPONS[key].id === localPlayerState.currentWeaponId)];
            if (currentWeapon.isMelee) return;

            const weaponAmmo = ammo[currentWeapon.id];
            const needed = currentWeapon.clip - weaponAmmo.currentClip;
            
            if (needed === 0 || weaponAmmo.reserve === 0) return;

            localPlayerState.isReloading = true;
            
            // Sync reloading state immediately if multiplayer
            if (gameMode === 'MULTIPLAYER') syncLocalPlayerState();

            // Simulating reload time
            setTimeout(() => {
                const ammoToReload = Math.min(needed, weaponAmmo.reserve);
                
                weaponAmmo.currentClip += ammoToReload;
                weaponAmmo.reserve -= currentWeapon.clip; // Mag disappears (decrease reserve by full clip capacity)
                
                weaponAmmo.reserve = Math.max(0, weaponAmmo.reserve);
                localPlayerState.isReloading = false;

                // Final sync of reloading state
                if (gameMode === 'MULTIPLAYER') syncLocalPlayerState();
            }, RELOAD_TIME_MS);
        }

        function shootEntity() {
            if (localPlayerState.health <= 0 || localPlayerState.isReloading) return;
            const currentWeapon = WEAPONS[Object.keys(WEAPONS).find(key => WEAPONS[key].id === localPlayerState.currentWeaponId)];

            const now = Date.now();
            if (now - lastShotTime < currentWeapon.fireRate) return;
            
            if (currentWeapon.isMelee) {
                // Simplified melee hit check
                entities.forEach(e => {
                    if (e.id === userId || e.health <= 0) return;
                    if (distance(localPlayerState.x, localPlayerState.y, e.x, e.y) < currentWeapon.range + PLAYER_RADIUS) {
                        if (gameMode === 'BOTS') {
                            processHitLocal(e.id, userId, currentWeapon.damage);
                        } else {
                            processHit(e.id, userId, currentWeapon.damage);
                        }
                    }
                });
                lastShotTime = now;
                return;
            }

            const weaponAmmo = ammo[currentWeapon.id];

            if (weaponAmmo.currentClip <= 0) {
                lastShotTime = now;
                return; 
            }

            weaponAmmo.currentClip--;
            lastShotTime = now;

            const bulletSpeed = currentWeapon.bulletSpeed;
            const velocityX = Math.cos(localPlayerState.angle) * bulletSpeed;
            const velocityY = Math.sin(localPlayerState.angle) * bulletSpeed;

            const muzzleX = localPlayerState.x + Math.cos(localPlayerState.angle) * (PLAYER_RADIUS + 10);
            const muzzleY = localPlayerState.y + Math.sin(localPlayerState.angle) * (PLAYER_RADIUS + 10);

            bullets.push({
                x: muzzleX,
                y: muzzleY,
                radius: currentWeapon.bulletRadius,
                velocityX: velocityX,
                velocityY: velocityY,
                damage: currentWeapon.damage,
                shooterId: userId,
                color: currentWeapon.color,
                targetType: 'ENEMY'
            });
        }
        
        function processHitLocal(targetId, shooterId, damage) {
            if (targetId.startsWith('bot_')) {
                const botIndex = bots.findIndex(bot => bot.id === targetId);
                if (botIndex !== -1) {
                    const bot = bots[botIndex];
                    bot.health -= damage;
                    if (bot.health <= 0) {
                        localPlayerState.kills++;
                        bot.x = T_SPAWN.x + Math.random() * 100 - 50;
                        bot.y = T_SPAWN.y + Math.random() * 100 - 50;
                        bot.health = 100;
                    }
                }
            }
        }
        
        function updatePlayerUI(state) {
            const currentWeapon = WEAPONS[Object.keys(WEAPONS).find(key => WEAPONS[key].id === state.currentWeaponId)];
            
            document.getElementById('scoreDisplay').textContent = `Kills: ${state.kills} | Deaths: ${state.deaths}`;
            document.getElementById('healthDisplay').textContent = `Health: ${Math.max(0, state.health)}`;
            
            const ammoDisplay = document.getElementById('ammoDisplay');
            if (state.isReloading) {
                 ammoDisplay.textContent = `${currentWeapon.name} | RELOADING... (${Math.round(RELOAD_TIME_MS/1000)}s)`;
                 ammoDisplay.style.borderColor = NEON_YELLOW;
                 ammoDisplay.style.boxShadow = `0 0 20px ${NEON_YELLOW}`;
            } else {
                ammoDisplay.textContent = `${currentWeapon.name} | ${ammo[currentWeapon.id].currentClip}/${ammo[currentWeapon.id].reserve}`;
                ammoDisplay.style.borderColor = currentWeapon.color;
                ammoDisplay.style.boxShadow = `0 0 15px ${currentWeapon.color}`;
            }
        }
        
        function resetLocalPlayerState() {
            localPlayerState = {
                id: userId, x: 0, y: 0, angle: 0, health: 100, kills: 0, deaths: 0, 
                currentWeaponId: WEAPONS.AK47.id, radius: PLAYER_RADIUS, isReloading: false
            };
            resetAmmo();
        }
        
        function setupGameListeners() {
            window.addEventListener('keydown', handleKeydown);
            window.addEventListener('keyup', handleKeyup);
            canvas.addEventListener('mousemove', updateAim);
            canvas.addEventListener('mousedown', playerShoot);
            canvas.addEventListener('touchstart', handleTouch);
        }

        function removeGameListeners() {
            window.removeEventListener('keydown', handleKeydown);
            window.removeEventListener('keyup', handleKeyup);
            if (canvas) {
                canvas.removeEventListener('mousemove', updateAim);
                canvas.removeEventListener('mousedown', playerShoot);
                canvas.removeEventListener('touchstart', handleTouch);
            }
        }

        function initializeGame(data) {
            // 1. Hide Lobby/Menu, Show Game UI
            messageBox.classList.add('hidden');
            mainMenu.classList.add('hidden');
            gameUI.classList.remove('hidden');

            // 2. Initialize Canvas & Context
            canvas = document.getElementById('gameCanvas');
            ctx = canvas.getContext('2d');
            canvas.width = CANVAS_WIDTH;
            canvas.height = CANVAS_HEIGHT;
            
            // 3. Setup Local State
            if (gameMode === 'MULTIPLAYER' && data) {
                localPlayerState = { ...data.players[userId] };
            } else if (gameMode === 'BOTS') {
                // State already set up in startBotsGame
            }
            resetAmmo(); // Full ammo upon game start

            // 4. Set Event Listeners
            setupGameListeners();

            // 5. Start Game Loop
            isRunning = true;
            gameLoop();
        }

        function gameLoop() {
            if (!isRunning) return;

            // 1. Update Local Player Movement
            updatePlayerMovement();
            
            // 2. Update Bots (Local Mode Only)
            if (gameMode === 'BOTS') {
                updateBots();
            }

            // 3. Sync State (Multiplayer Only)
            syncLocalPlayerState(); 
            
            // 4. Populate Entities array for drawing and collision checks
            if (gameMode === 'MULTIPLAYER' && roomData && roomData.players) {
                entities = Object.values(roomData.players).filter(p => p.id !== userId);
                entities.push(localPlayerState); 
            } else if (gameMode === 'BOTS') {
                entities = bots.concat(localPlayerState);
            }
            
            // Update UI based on local player state
            updatePlayerUI(localPlayerState);

            // 5. Bullet Updates & Collision (Local logic)
            updateBullets();
            checkDamageCollisions(); 

            // 6. Drawing
            ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
            drawMap();
            drawBullets();
            drawEntities();
            drawMinimap();

            gameLoopId = requestAnimationFrame(gameLoop);
        }

        function gameOver(message, showMenu = true) {
            isRunning = false;
            if (gameLoopId) cancelAnimationFrame(gameLoopId);
            removeGameListeners();
            
            messageBox.classList.remove('hidden');
            document.getElementById('finalScore').innerHTML = `Game Over`;
            
            let finalMessage = message || `You disconnected or the room was closed.`;
            if (gameMode === 'BOTS') {
                 finalMessage = `Kills: ${localPlayerState.kills} | Deaths: ${localPlayerState.deaths}`;
            }
            document.getElementById('highScoreText').innerHTML = finalMessage;
            
            document.getElementById('lobbyRoomId').textContent = gameMode === 'MULTIPLAYER' && roomData ? roomData.id : 'N/A';
            startGameButton.classList.add('hidden');
            document.getElementById('leaveButton').textContent = 'Return to Menu';
            
            if (showMenu) leaveRoom();
        }

        // --- Event Handlers ---
        function handleKeydown(e) { 
            keys[e.key] = true; 
            if (e.key === 'r' || e.key === 'R') {
                reloadGun();
            }
            if (e.key === '1' || e.key === '2' || e.key === '3') {
                const newWeaponId = parseInt(e.key);
                localPlayerState.currentWeaponId = newWeaponId;
            }
        }
        function handleKeyup(e) { keys[e.key] = false; }
        function playerShoot(e) { if (isRunning) shootEntity(); }
        function handleTouch(e) {
            e.preventDefault();
            if (e.touches.length > 0) {
                const rect = canvas.getBoundingClientRect();
                const touch = e.touches[0];
                mousePos.x = touch.clientX - rect.left;
                mousePos.y = touch.clientY - rect.top;
                localPlayerState.angle = Math.atan2(mousePos.y - localPlayerState.y, mousePos.x - localPlayerState.y);
                shootEntity();
            }
        }
        
        // --- Initialization and Button Setup ---

        window.onload = async function() {
            await firebaseInit();

            hostButton.addEventListener('click', hostGame);
            joinButton.addEventListener('click', joinGame);
            botsButton.addEventListener('click', startBotsGame);
            document.getElementById('leaveButton').addEventListener('click', leaveRoom);
            
            startGameButton.addEventListener('click', async () => {
                if (roomData && roomData.hostId === userId && gameMode === 'MULTIPLAYER') {
                    try {
                        await updateDoc(roomRef, { status: 'INGAME' });
                    } catch (e) {
                        console.error("Failed to start game:", e);
                    }
                }
            });

            document.getElementById('leaveButton').addEventListener('click', leaveRoom);
        };
    </script>
</body>
</html>